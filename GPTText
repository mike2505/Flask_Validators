Tree: 
├── controllers
│   ├── error_handler.py
│   ├── __init__.py
│   └── validator.py
├── decorators
│   ├── __init__.py
│   └── validation_decorator.py
├── __init__.py
├── models
│   ├── fields.py
│   ├── __init__.py
│   ├── schema.py
│   └── validate_db.py


controllers/validator.py:

class DataValidator:
    def __init__(self, schema, data):
        self.schema = schema
        self.data = data

    def validate(self):
        errors = {}
        for field_name, field in self.schema.fields.items():
            value = self.data.get(field_name)
            if value is None and field.required:
                errors[field_name] = 'This field is required.'
            elif value is not None:
                is_valid, error_message = field.validate(value)
                if not is_valid:
                    errors[field_name] = error_message
        return errors

decorators/validation_decorator.py:

from functools import wraps
from flask import request, jsonify
from flask_validators.controllers.validator import DataValidator
from flask_validators.models.schema import Schema
from flask_validators.models.fields import Field
from flask_validators.models.validate_db import check_unique_fields
from sqlalchemy.orm import sessionmaker

field_schemas = {HERE ARE SOME FIELDS }

def validate_form(*fields):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            data = request.form.to_dict()
            file_data = {k: v for k, v in request.files.items() if k in fields}

            if not data and not file_data:
                return jsonify({'error': 'No data provided.'}), 400

            errors = {}
            for field in fields:
                if field not in field_schemas:
                    continue

                schema = field_schemas[field]
                schema.data = data  # Pass the whole data
                value = data.get(field) if field in data else file_data.get(field)

                if not value:
                    errors[field] = "Missing data"
                    continue

                is_valid, error_message = schema.validate(value)
                if not is_valid:
                    errors[field] = error_message

            if errors:
                return jsonify(errors), 400

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_db(model_class, Session, **validators):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            session = Session()
            data = request.form.to_dict()

            errors = {}

            for field, validator in validators.items():
                value = data.get(field)
                if value is not None:
                    is_valid, error_message = validator(model_class, session, value, data)
                    if not is_valid:
                        errors[field] = error_message

            if errors:
                return jsonify(errors), 400

            return f(*args, **kwargs)
        return decorated_function
    return decorator

models/fields.py:

import re
import json

from urllib.parse import urlparse
from datetime import datetime

class Field:
    def __init__(self, required=False, type=None, validators=None):
        self.required = required
        self.type = type
        self.validators = validators or []

    def validate(self, value):
        if self.required and value is None:
            return False, 'This field is required.'

        if self.type:
            try:
                if self.type == 'string':
                    value = str(value)
                elif self.type == 'integer':
                    value = int(value)
                elif self.type == 'float':
                    value = float(value)
                elif self.type == 'boolean':
                    value = bool(value)
            except ValueError:
                return False, f'Expected a {self.type}.'

            # Add more type validations as needed

        for validator in self.validators:
            validator_name = validator['name']
            if validator_name == 'min_age':
                validator_name = 'age'
            elif validator_name == 'max_age':
                validator_name = 'age'
            elif validator_name == 'email':
                validator_name = 'email'

            validator_func = getattr(self, f'validate_{validator_name}', None)
            if not validator_func:
                continue

            validator_args = validator.get('args', ())
            validator_kwargs = validator.get('kwargs', {})

            if validator_name == 'age':
                min_age, max_age = validator_args
                is_valid, error_message = validator_func(value, min_age, max_age, **validator_kwargs)
            else:
                is_valid, error_message = validator_func(value, *validator_args, **validator_kwargs)

            if not is_valid:
                custom_message = validator.get('message')
                return False, custom_message if custom_message else error_message

        return True, None

    def validate_email(self, value):
        if re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', value):
            return True, None
        return False, 'Invalid email address.'

    def validate_name(self, value):
        if isinstance(value, str) and value.strip():
            return True, None
        return False, 'Invalid name.'

    def .... - HERE ARE ANOTHER FUNCTIONS WITH SAME STRUCTURE

models/schema.py:

import re
import json

from urllib.parse import urlparse
from datetime import datetime

class Schema:
    def __init__(self, schema):
        self.schema = schema
        self.fields = schema

    def validate(self, data):
        errors = {}
        for field, rules in self.schema.items():
            value = data.get(field)
            field_errors = []

            if rules.get('required') and not value:
                field_errors.append('This field is required.')

            if 'type' in rules and not self.validate_type(value, rules['type']):
                field_errors.append(f'Expected a {rules["type"]}.')

            if 'validators' in rules:
                for validator in rules['validators']:
                    validator_name = validator['name']
                    validator_func = getattr(self, f'validate_{validator_name}')
                    validator_args = validator.get('args', ())
                    validator_kwargs = validator.get('kwargs', {})

                    if not validator_func(value, *validator_args, **validator_kwargs):
                        field_errors.append(validator['message'])

            if field_errors:
                errors[field] = field_errors[0] if len(field_errors) == 1 else field_errors

        return errors

    def validate_type(self, value, expected_type):
        if expected_type == 'string':
            return isinstance(value, str)
        elif expected_type == 'integer':
            return isinstance(value, int)
        elif expected_type == 'float':
            return isinstance(value, float)
        elif expected_type == 'boolean':
            return isinstance(value, bool)
        # Add more type validations as needed

    def validate_email(self, value):
        if re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', value):
            return True, None
        return False, 'Invalid email address.'

    def validate_name(self, value):
        if isinstance(value, str) and value.strip():
            return True, None
        return False, 'Invalid name.'
 
    def .... - ANOTHER FUNCTIONS WITH SAME STRUCTURE


models/validate_db.py:

from functools import wraps
from flask import request, jsonify
from sqlalchemy.orm import sessionmaker
import re

def check_unique(model_class, session, value, data):
    query = session.query(model_class).filter(getattr(model_class, data.get('field')) == value).first()
    if query and query.id != data.get('id'):  # Compare against the existing record's ID
        return False, f'{data.get("field").capitalize()} already exists.'
    return True, None

def check_null(model_class, session, value, data):
    if not value:
        return False, f'{data.get("field").capitalize()} is required.'
    return True, None

def check_existence(model_class, session, value, data):
    id_value = value
    if id_value:
        query = session.query(model_class).filter(getattr(model_class, data.get('field')) == id_value).first()
        if not query:
            return False, f'{data.get("field").capitalize()} does not exist.'
    return True, None



Here is exmaple flask:

from flask import Flask, request, jsonify
from flask_validators import validate_form, Schema, Field, DataValidator, validate_db
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

app = Flask(__name__)

database_url = 'sqlite:///test_database.db'
engine = create_engine(database_url)
Session = sessionmaker(bind=engine)

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True)
    email = Column(String(100), unique=True)

Base.metadata.create_all(engine)

Base.metadata.drop_all(engine, tables=[User.__table__])
Base.metadata.create_all(engine)

session = Session()
user1 = User(username='testuser1', email='test1@example.com')
user2 = User(username='testuser2', email='test2@example.com')
session.add(user1)
session.add(user2)
session.commit()

@app.route('/validate_unique', methods=['POST'])
@validate_db(User, Session, username=check_unique, email=check_null)
def validate_unique():
    return jsonify({'success': True, 'message': 'Data is valid.'})

if __name__ == '__main__':
    app.run(debug=True)

And I have error:
Traceback (most recent call last):
  File "/home/mikef0x/Flask_Validators/tests/test_flask.py", line 35, in <module>
    @validate_db(User, Session, username=check_unique, email=check_null)
                                         ^^^^^^^^^^^^
NameError: name 'check_unique' is not defined
