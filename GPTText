fields.py:

import re
import json

from urllib.parse import urlparse
from datetime import datetime

class Field:
    def __init__(self, required=False, type=None, validators=None):
        self.required = required
        self.type = type
        self.validators = validators or []

    def validate(self, value):
        if self.required and value is None:
            return False, 'This field is required.'

        if self.type:
            try:
                if self.type == 'string':
                    value = str(value)
                elif self.type == 'integer':
                    value = int(value)
                elif self.type == 'float':
                    value = float(value)
                elif self.type == 'boolean':
                    value = bool(value)
            except ValueError:
                return False, f'Expected a {self.type}.'

            # Add more type validations as needed

        for validator in self.validators:
            validator_name = validator['name']
            if validator_name == 'min_age':
                validator_name = 'age'
            elif validator_name == 'max_age':
                validator_name = 'age'
            elif validator_name == 'email':
                validator_name = 'email'

            validator_func = getattr(self, f'validate_{validator_name}', None)
            if not validator_func:
                continue

            validator_args = validator.get('args', ())
            validator_kwargs = validator.get('kwargs', {})

            if validator_name == 'age':
                min_age, max_age = validator_args
                is_valid, error_message = validator_func(value, min_age, max_age, **validator_kwargs)
            else:
                is_valid, error_message = validator_func(value, *validator_args, **validator_kwargs)

            if not is_valid:
                custom_message = validator.get('message')
                return False, custom_message if custom_message else error_message

        return True, None

    def validate_email(self, value):
        if re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', value):
            return True, None
        return False, 'Invalid email address.'

    def validate_name(self, value):
        if isinstance(value, str) and value.strip():
            return True, None
        return False, 'Invalid name.'

    def validate_age(self, value, min_age=0, max_age=120):
        if isinstance(value, int) and min_age <= value <= max_age:
            return True, None
        return False, f'Age must be between {min_age} and {max_age}.'

    def validate_password(self, value, min_length=8, max_length=16, require_special_char=True):
        if isinstance(value, str) and min_length <= len(value) <= max_length:
            if require_special_char and re.search(r'\W', value):
                return True, None
        return False, 'Invalid password.'

    def validate_json(self, value):
        try:
            json.loads(value)
            return True, None
        except json.JSONDecodeError:
            return False, 'Invalid JSON.'

    def validate_phone(self, value):
        if re.match(r'^\+?1?\d{9,15}$', value):
            return True, None
        return False, 'Invalid phone number.'

    def validate_zipcode(self, value):
        if re.match(r'^\d{5}(-\d{4})?$', value):  # US zipcode format
            return True, None
        return False, 'Invalid zipcode.'

    def validate_date(self, value):
        try:
            datetime.strptime(value, '%Y-%m-%d')  # assuming date format to be 'YYYY-MM-DD'
            return True, None
        except ValueError:
            return False, 'Invalid date.'

    def validate_credit_card(self, value):
        # naive check for 16 digit number with optional hyphens or spaces
        if re.match(r'^(\d{4}[-\s]?){3}\d{4}$', value):
            return True, None
        return False, 'Invalid credit card number.'

    def validate_ssn(self, value):
        # naive check for US SSN (XXX-XX-XXXX)
        if re.match(r'^\d{3}-\d{2}-\d{4}$', value):
            return True, None
        return False, 'Invalid social security number.'

    def validate_url(self, value):
        try:
            result = urlparse(value)
            return all([result.scheme, result.netloc]), 'Invalid URL.'
        except ValueError:
            return False, 'Invalid URL.'

    def validate_ip_address(self, value):
        if re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', value):  # naive IPv4 check
            return True, None
        return False, 'Invalid IP address.'

    def validate_hex_color(self, value):
        if re.match(r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$', value):
            return True, None
        return False, 'Invalid hexadecimal color code.'

    def validate_latitude(self, value):
        if re.match(r'^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?)$', value):
            return True, None
        return False, 'Invalid latitude.'

    def validate_longitude(self, value):
        if re.match(r'^[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$', value):
            return True, None
        return False, 'Invalid longitude.'

    def validate_file(self, value, allowed_extensions=None, max_size=None):
        if allowed_extensions and value.filename.split('.')[-1] not in allowed_extensions:
            return False, 'Invalid file extension.'
        
        if max_size and value.content_length > max_size:
            return False, 'File size is too large.'

        return True, None

    def validate_confirm_password(self, value, password_field):
        password = self.data.get(password_field)
        if password != value:
            return False, 'Passwords must match.'
        return True, None

validation_decorator.py:

from functools import wraps
from flask import request, jsonify
from flask_validators.controllers.validator import DataValidator
from flask_validators.models.schema import Schema
from flask_validators.models.fields import Field

field_schemas = {
    'email': Field(required=True, type='string', validators=[
        {'name': 'email', 'message': 'Invalid email address.'}
    ]),
    'name': Field(required=True, type='string', validators=[
        {'name': 'name', 'message': 'Invalid name.'}
    ]),
    'age': Field(required=True, type='integer', validators=[
        {'name': 'age', 'message': 'Invalid age.', 'args': (0, 120)}
    ]),
    'password': Field(required=True, type='string', validators=[
        {'name': 'password', 'message': 'Invalid password.', 'kwargs': {'min_length': 8, 'max_length': 16, 'require_special_char': True}}
    ]),
    'confirm_password': Field(required=True, type='string', validators=[
        {'name': 'confirm_password', 'message': 'Passwords must match.', 'kwargs': {'password_field': 'password'}}
    ]),
    'json': Field(required=True, type='string', validators=[
        {'name': 'json', 'message': 'Invalid JSON.'}
    ]),
    'phone': Field(required=True, type='string', validators=[
        {'name': 'phone', 'message': 'Invalid phone number.'}
    ]),
    'zipcode': Field(required=True, type='string', validators=[
        {'name': 'zipcode', 'message': 'Invalid zipcode.'}
    ]),
    'date': Field(required=True, type='string', validators=[
        {'name': 'date', 'message': 'Invalid date.'}
    ]),
    'credit_card': Field(required=True, type='string', validators=[
        {'name': 'credit_card', 'message': 'Invalid credit card number.'}
    ]),
    'ssn': Field(required=True, type='string', validators=[
        {'name': 'ssn', 'message': 'Invalid social security number.'}
    ]),
    'url': Field(required=True, type='string', validators=[
        {'name': 'url', 'message': 'Invalid URL.'}
    ]),
    'ip_address': Field(required=True, type='string', validators=[
        {'name': 'ip_address', 'message': 'Invalid IP address.'}
    ]),
    'hex_color': Field(required=True, type='string', validators=[
        {'name': 'hex_color', 'message': 'Invalid hexadecimal color code.'}
    ]),
    'latitude': Field(required=True, type='string', validators=[
        {'name': 'latitude', 'message': 'Invalid latitude.'}
    ]),
    'longitude': Field(required=True, type='string', validators=[
        {'name': 'longitude', 'message': 'Invalid longitude.'}
    ]),
    'file': Field(required=True, type='file', validators=[
        {'name': 'file', 'message': 'Invalid file.', 'kwargs': {'allowed_extensions': ['jpg', 'png', 'pdf', 'txt'], 'max_size': 1024 * 1024 * 5}}  # 5MB
    ]),
}

def validate_form(*fields):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            data = request.form.to_dict()
            file_data = {k: v for k, v in request.files.items() if k in fields}

            if not data and not file_data:
                return jsonify({'error': 'No data provided.'}), 400

            errors = {}
            for field in fields:
                if field not in field_schemas:
                    continue

                schema = field_schemas[field]
                schema.data = data  # Pass the whole data
                value = data.get(field) if field in data else file_data.get(field)

                if not value:
                    errors[field] = "Missing data"
                    continue

                is_valid, error_message = schema.validate(value)
                if not is_valid:
                    errors[field] = error_message

            if errors:
                return jsonify(errors), 400

            return f(*args, **kwargs)
        return decorated_function
    return decorator

schema.py:

import re
import json

from urllib.parse import urlparse
from datetime import datetime

class Schema:
    def __init__(self, schema):
        self.schema = schema
        self.fields = schema

    def validate(self, data):
        errors = {}
        for field, rules in self.schema.items():
            value = data.get(field)
            field_errors = []

            if rules.get('required') and not value:
                field_errors.append('This field is required.')

            if 'type' in rules and not self.validate_type(value, rules['type']):
                field_errors.append(f'Expected a {rules["type"]}.')

            if 'validators' in rules:
                for validator in rules['validators']:
                    validator_name = validator['name']
                    validator_func = getattr(self, f'validate_{validator_name}')
                    validator_args = validator.get('args', ())
                    validator_kwargs = validator.get('kwargs', {})

                    if not validator_func(value, *validator_args, **validator_kwargs):
                        field_errors.append(validator['message'])

            if field_errors:
                errors[field] = field_errors[0] if len(field_errors) == 1 else field_errors

        return errors

    def validate_type(self, value, expected_type):
        if expected_type == 'string':
            return isinstance(value, str)
        elif expected_type == 'integer':
            return isinstance(value, int)
        elif expected_type == 'float':
            return isinstance(value, float)
        elif expected_type == 'boolean':
            return isinstance(value, bool)
        # Add more type validations as needed

    def validate_email(self, value):
        if re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', value):
            return True, None
        return False, 'Invalid email address.'

    def validate_name(self, value):
        if isinstance(value, str) and value.strip():
            return True, None
        return False, 'Invalid name.'

    def validate_age(self, value, min_age=0, max_age=120):
        if isinstance(value, int) and min_age <= value <= max_age:
            return True, None
        return False, f'Age must be between {min_age} and {max_age}.'

    def validate_password(self, value, min_length=8, max_length=16, require_special_char=True):
        if isinstance(value, str) and min_length <= len(value) <= max_length:
            if require_special_char and re.search(r'\W', value):
                return True, None
        return False, 'Invalid password.'

    def validate_json(self, value):
        try:
            json.loads(value)
            return True, None
        except json.JSONDecodeError:
            return False, 'Invalid JSON.'

    def validate_phone(self, value):
        if re.match(r'^\+?1?\d{9,15}$', value):
            return True, None
        return False, 'Invalid phone number.'

    def validate_zipcode(self, value):
        if re.match(r'^\d{5}(-\d{4})?$', value):  # US zipcode format
            return True, None
        return False, 'Invalid zipcode.'

    def validate_date(self, value):
        try:
            datetime.strptime(value, '%Y-%m-%d')  # assuming date format to be 'YYYY-MM-DD'
            return True, None
        except ValueError:
            return False, 'Invalid date.'

    def validate_credit_card(self, value):
        # naive check for 16 digit number with optional hyphens or spaces
        if re.match(r'^(\d{4}[-\s]?){3}\d{4}$', value):
            return True, None
        return False, 'Invalid credit card number.'

    def validate_ssn(self, value):
        # naive check for US SSN (XXX-XX-XXXX)
        if re.match(r'^\d{3}-\d{2}-\d{4}$', value):
            return True, None
        return False, 'Invalid social security number.'

    def validate_url(self, value):
        try:
            result = urlparse(value)
            return all([result.scheme, result.netloc]), 'Invalid URL.'
        except ValueError:
            return False, 'Invalid URL.'

    def validate_ip_address(self, value):
        if re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', value):  # naive IPv4 check
            return True, None
        return False, 'Invalid IP address.'

    def validate_hex_color(self, value):
        if re.match(r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$', value):
            return True, None
        return False, 'Invalid hexadecimal color code.'

    def validate_latitude(self, value):
        if re.match(r'^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?)$', value):
            return True, None
        return False, 'Invalid latitude.'

    def validate_longitude(self, value):
        if re.match(r'^[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$', value):
            return True, None
        return False, 'Invalid longitude.'

    def validate_file(self, value, allowed_extensions=None, max_size=None):
        if allowed_extensions and value.filename.split('.')[-1] not in allowed_extensions:
            return False, 'Invalid file extension.'
        
        if max_size and value.content_length > max_size:
            return False, 'File size is too large.'

        return True, None

    def validate_confirm_password(self, value, password_field):
        password = self.data.get(password_field)
        if password != value:
            return False, 'Passwords must match.'
        return True, None

validator.py:

class DataValidator:
    def __init__(self, schema, data):
        self.schema = schema
        self.data = data

    def validate(self):
        errors = {}
        for field_name, field in self.schema.fields.items():
            value = self.data.get(field_name)
            if value is None and field.required:
                errors[field_name] = 'This field is required.'
            elif value is not None:
                is_valid, error_message = field.validate(value)
                if not is_valid:
                    errors[field_name] = error_message
        return errors



I want to implement database validator - I want to create new decrator - validate_db... let's start from easy and move to hard.

Firstly help me implement unique checker, for example start with email and username, new validator should check if email already exists in database.


It would work like this -

user imports my package
user specifies database (let's start with sqlalchemy support)
user declares endpoint with validate_db decorator